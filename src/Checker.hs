module Checker where

import Base
import Control.Monad.State
import Data.Bifunctor (bimap, first, second)
import qualified Data.Map as M
import qualified Data.Set as S

-- set of all type vars that were in type (for generateNewType)
type AllVarsSet = S.Set TypeVar

-- set of type vars generated by generateNewType method (they (a0, a1, a2,...) for term variables not in context
type UnknownVarsSet = S.Set TypeVar

-- Type equations for unification algorithm
type Equations = [(Type, Type)]

-- generates new type var, inserts it in UnknownVarsSet and AllVarsSet and increments counter to actual value
generateNewTypeVar :: State (Context, (Equations, (AllVarsSet, (UnknownVarsSet, Int)))) TypeVar
generateNewTypeVar = do
  (ctx, (eqs, (typeVars, (unknown, i)))) <- get
  let name = "a" ++ show i
   in if name `S.member` typeVars
        then do
          modify $ second $ second $ second $ second (+ 1)
          generateNewTypeVar
        else do
          put (ctx, (eqs, (name `S.insert` typeVars, (name `S.insert` unknown, i + 1))))
          return name

typeEquations :: Term -> State (Context, (Equations, (AllVarsSet, (UnknownVarsSet, Int)))) Type
typeEquations (V x) = do
  (ctx, _) <- get
  case M.lookup x ctx of
    Nothing -> do
      a <- generateNewTypeVar
      modify $ first $ M.insert x (T a)
      return $ T a
    Just t -> return t
typeEquations (e :@ f) = do
  tE <- typeEquations e
  tF <- typeEquations f
  a <- generateNewTypeVar
  modify $ second $ first ((tE, tF :=> T a) :)
  return $ T a
typeEquations (L x t e) = do
  xValueWas <- gets $ fst . first (M.lookup x)
  modify $ first $ M.insert x t
  tE <- typeEquations e
  case xValueWas of
    Nothing -> modify $ first $ M.delete x
    Just tX -> modify $ first $ M.insert x tX
  return (t :=> tE)
typeEquations (e :@. t) = do
  tE <- typeEquations e
  a <- generateNewTypeVar
  b <- generateNewTypeVar
  modify $ second $ first $ \eqs -> (tE, ForAll a (T b)) : (T a, t) : eqs
  return $ T b
typeEquations (LL a e) = do
  tE <- typeEquations e
  return $ ForAll a tE

-- substitutes the type instead of the type var
subst :: TypeVar -> Type -> Type -> Type
subst a t other@(T b) = if a == b then t else other
subst a t (t1 :=> t2) = subst a t t1 :=> subst a t t2
subst a t other@(ForAll b t') = if a == b then other else ForAll b $ subst a t t'

-- checks if the type contains the type var
containsTypeVar :: TypeVar -> Type -> Bool
containsTypeVar a (T y) = a == y
containsTypeVar a (t1 :=> t2) = containsTypeVar a t1 || containsTypeVar a t2
containsTypeVar a (ForAll b t) = a /= b && containsTypeVar a t

-- 2-nd order unification algorithm for type equations
-- We consider unknown types (a0, a1.., generated by ourselves for term variables not in context) to be any type.
-- And when algorithm have equation kind of `ai = ...` or `... = ai` (where `ai` is unknown generated type var),
-- he substitutes (ai := ...) in all equations
unification :: State (Context, (Equations, (AllVarsSet, (UnknownVarsSet, Int)))) (Either String Context)
unification = do
  (ctx, (eqs', (_, (unknown, _)))) <- get
  case eqs' of
    [] -> return $ Right ctx
    (t1@(T a), t2@(T b)) : eqs ->
      if a == b
        then do
          modify $ second $ first $ const eqs
          unification
        else
          if a `S.member` unknown
            then do
              modify $ second $ first $ const eqs
              modify $ second $ first $ map (bimap (subst a t2) (subst a t2))
              unification
            else
              if b `S.member` unknown
                then do
                  modify $ second $ first $ const ((t2, t1) : eqs)
                  unification
                else return $ Left $ "Couldn't match expected type " ++ b ++ " with actual type " ++ a
    (T a, t2) : eqs ->
      if containsTypeVar a t2
        then return $ Left $ "Occurs check: " ++ a ++ " = " ++ show t2
        else
          if a `S.notMember` unknown
            then return $ Left $ "Couldn't match expected type " ++ show t2 ++ " with actual type " ++ a
            else do
              modify $ second $ first $ const eqs
              modify $ second $ first $ map (bimap (subst a t2) (subst a t2))
              unification
    (t1, t2@(T _)) : eqs -> do
      modify $ second $ first $ const ((t2, t1) : eqs)
      unification
    (t1 :=> t2, t1' :=> t2') : eqs -> do
      modify $ second $ first $ const ((t1, t1') : (t2, t2') : eqs)
      unification
    (ForAll a t1, ForAll b t2) : eqs -> do
      c <- generateNewTypeVar
      modify $ second $ first $ const ((subst a (T c) t1, subst b (T c) t2) : eqs)
      unification
    (t, t') : _ -> return $ Left $ "Cannot match " ++ show t ++ " with " ++ show t'

findAllTypeNames :: Type -> AllVarsSet
findAllTypeNames (T a) = S.singleton a
findAllTypeNames (t1 :=> t2) = S.union (findAllTypeNames t1) (findAllTypeNames t2)
findAllTypeNames (ForAll _ t) = findAllTypeNames t

findAllTypeNamesFromContext :: Context -> AllVarsSet
findAllTypeNamesFromContext ctx = foldl S.union S.empty $ map findAllTypeNames $ M.elems ctx

check :: TypeInference -> Either (Type, String) Context
check (ctx, term, usersType) =
  evalState
    ( do
        actualType <- typeEquations term
        (_, (eqs, _)) <- get
        modify $ second $ first $ const ((usersType, actualType) : eqs)
        res <- unification
        case res of
          Left s -> return $ Left (actualType, s)
          Right c -> return $ Right c
    )
    (ctx, ([], (findAllTypeNamesFromContext ctx `S.union` findAllTypeNames usersType, (S.empty, 0))))
