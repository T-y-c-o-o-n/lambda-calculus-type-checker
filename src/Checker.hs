module Checker where

import Base
import Control.Monad.State
import Data.Bifunctor (bimap, first, second)
import qualified Data.Map as M
import qualified Data.Set as S

-- set of all type vars that were in type (for generateNewType)
type AllVarsSet = S.Set TypeVar

-- set of type vars generated by generateNewType method (they (a0, a1, a2,...) for term variables not in context
type UnknownVarsSet = S.Set TypeVar

-- Type equations for unification algorithm
type Equations = [(Type, Type)]

-- generates new type var, inserts it in UnknownVarsSet and AllVarsSet and increments counter to actual value
generateNewType :: State (Context, (Equations, (AllVarsSet, (UnknownVarsSet, Int)))) Type
generateNewType = do
  (ctx, (eqs, (typeVars, (unknown, i)))) <- get
  let name = "a" ++ show i
   in let newType = T name
       in if name `S.member` typeVars
            then do
              modify $ second $ second $ second $ second (+ 1)
              generateNewType
            else do
              put (ctx, (eqs, (name `S.insert` typeVars, (name `S.insert` unknown, i + 1))))
              return newType

typeEquations :: Term -> State (Context, (Equations, (AllVarsSet, (UnknownVarsSet, Int)))) Type
typeEquations (V x) = do
  (ctx, _) <- get
  case M.lookup x ctx of
    Nothing -> do
      t <- generateNewType
      modify $ first $ M.insert x t
      return t
    Just t -> return t
typeEquations (e :@ f) = do
  tE <- typeEquations e
  tF <- typeEquations f
  t <- generateNewType
  modify $ second $ first ((tE, tF :=> t) :)
  return t
typeEquations (L x t e) = do
  xValueWas <- gets $ fst . first (M.lookup x)
  modify $ first $ M.insert x t
  tE <- typeEquations e
  case xValueWas of
    Nothing -> modify $ first $ M.delete x
    Just tX -> modify $ first $ M.insert x tX
  return (t :=> tE)
typeEquations (e :@. t) = do
  tE <- typeEquations e
  t' <- generateNewType
  modify $ second $ first ((tE, t :=> t') :)
  return t'
typeEquations (LL a e) = do
  tE <- typeEquations e
  return $ ForAll a tE

-- substitutes the type instead of the type var
subst :: TypeVar -> Type -> Type -> Type
subst a t other@(T b) = if a == b then t else other
subst a t (t1 :=> t2) = subst a t t1 :=> subst a t t2
subst a t other@(ForAll b t') = if a == b then other else ForAll b $ subst a t t'

-- checks if the type contains the type var
containsTypeVar :: TypeVar -> Type -> Bool
containsTypeVar a (T y) = a == y
containsTypeVar a (t1 :=> t2) = containsTypeVar a t1 || containsTypeVar a t2
containsTypeVar a (ForAll b t) = a /= b && containsTypeVar a t

-- 2-nd order unification algorithm for type equations
-- We consider unknown types (a0, a1.., generated by ourselves for term variables not in context) to be any type.
-- And when algorithm have equation kind of `ai = ...` or `... = ai` (where `ai` is unknown generated type var),
-- he substitutes (ai := ...) in all equations
unification :: UnknownVarsSet -> (Context, Equations) -> Either String Context
unification _ (ctx, []) = Right ctx
unification unknown (ctx, (t1@(T a), t2@(T b)) : eqs)
  | a == b = unification unknown (ctx, eqs)
  | a `S.member` unknown = unification unknown (ctx, map (bimap (subst a t2) (subst a t2)) eqs)
  | b `S.member` unknown = unification unknown (ctx, (t2, t1) : eqs)
  | otherwise = Left $ "Couldn't match expected type " ++ b ++ " with actual type " ++ a
unification unknown (ctx, (T a, t2) : eqs)
  | containsTypeVar a t2 = Left $ "Occurs check: " ++ a ++ " = " ++ show t2
  | a `S.notMember` unknown = Left $ "Couldn't match expected type " ++ show t2 ++ " with actual type " ++ a
  | otherwise = unification unknown (ctx, map (bimap (subst a t2) (subst a t2)) eqs)
unification unknown (ctx, (t1, t2@(T _)) : eqs) = unification unknown (ctx, (t2, t1) : eqs)
unification unknown (ctx, (t1 :=> t2, t1' :=> t2') : eqs) = unification unknown (ctx, (t1, t1') : (t2, t2') : eqs)
unification unknown (ctx, (ForAll a t, ForAll b t') : eqs) = unification unknown (ctx, (T a, T b) : (t, t') : eqs)
unification _ (_, (t, t') : _) = Left $ "Cannot match " ++ show t ++ " with " ++ show t'

findAllTypeNames :: Type -> AllVarsSet
findAllTypeNames (T a) = S.singleton a
findAllTypeNames (t1 :=> t2) = S.union (findAllTypeNames t1) (findAllTypeNames t2)
findAllTypeNames (ForAll _ t) = findAllTypeNames t

findAllTypeNamesFromContext :: Context -> AllVarsSet
findAllTypeNamesFromContext ctx = foldl S.union S.empty $ map findAllTypeNames $ M.elems ctx

check :: TypeInference -> Either (Type, String) Context
check (ctx, term, usersType) =
  let (actualType, (ctx', (eqs, (_, (unknown, _))))) = runState (typeEquations term) (ctx, ([], (findAllTypeNamesFromContext ctx `S.union` findAllTypeNames usersType, (S.empty, 0))))
   in case unification unknown (ctx', (usersType, actualType) : eqs) of
        Left e -> Left (actualType, e)
        Right c -> Right c
